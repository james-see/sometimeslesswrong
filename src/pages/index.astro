---
import BaseHead from '../components/BaseHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import { SITE_TITLE, SITE_DESCRIPTION } from '../consts';
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
		<script type="application/ld+json" set:html={JSON.stringify({
			"@context": "https://schema.org",
			"@type": "WebSite",
			"name": SITE_TITLE,
			"url": "https://sometimeslesswrong.com",
			"description": SITE_DESCRIPTION,
			"author": {
				"@type": "Person",
				"name": "James Campbell"
			}
		})} />
		<style>
html, body {
	padding: 0;
	margin: 0;
}
main {
	padding: 0;
    width: 100%;  /* Use the full width of the body */
    height: 100%; /* Use the full height of the body */
    display: flex;
    justify-content: center;  /* Center horizontally */
    align-items: center;      /* Center vertically */
}

.scene {
    position: relative;
    width: 50vw;
    height: 70vh;
    margin-top: -6vh;  /* Shift up to match canvas center */
    /* perspective: 1000px; */
    display: flex; /* This enables flexbox for centering within the scene itself */
    flex-wrap: wrap; /* This allows cubes to wrap within the scene */
    align-items: center;
    justify-content: center;
}

.cube {
	border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100px;
    height: 100px;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'UniversLTPro', sans-serif;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 0.12em;
    transform-style: preserve-3d;
    transition: transform 3.14s ease-in-out, background-color 1s ease-in-out;
    transform: translate(-50%, -50%) rotateX(20deg) rotateY(20deg);
	opacity: 0.7;
	box-shadow: 10px 10px 20px rgba(0,0,0,0.5);
}

.cube span {
    z-index: 2;
    position: relative;
    padding: 5px;
    text-align: center;
    /* background: rgba(0, 0, 0, 0.5); */
}

@keyframes rotate {
  from {
    transform: translate(-50%, -50%) rotateX(0) rotateY(0) rotateZ(0);
  }
  to {
    transform: translate(-50%, -50%) rotateX(360deg) rotateY(360deg) rotateZ(360deg);
  }
}

@keyframes moveAround {
  0%, 100% {
    transform: translate(-50%, -50%) translateX(-200px) translateY(-200px);
  }
  25% {
    transform: translate(-50%, -50%) translateX(200px) translateY(-200px);
  }
  50% {
    transform: translate(-50%, -50%) translateX(200px) translateY(200px);
  }
  75% {
    transform: translate(-50%, -50%) translateX(-200px) translateY(200px);
  }
}

@keyframes colorChange {
  0%, 100% {
    background: red;
  }
  25% {
    background: blue;
  }
  50% {
    background: green;
  }
  75% {
    background: yellow;
  }
}
.cube:hover {
  animation-play-state: paused;
}
@media (max-width: 768px) {
    .scene {
        width: 90vw;  /* Full viewport width on mobile devices */
    }
}
</style>
	</head>
	<body>
		<canvas id="trailCanvas" style="position: absolute; top: 44%; left: 50%; transform: translate(-50%, -50%); z-index: 0; height: calc(100vh - 300px); width: 80vw;"></canvas>

		<Header />
		<main>
			<div class="scene">
				<div class="cube" data-index="1"><span>METATRON</span></div>
				<div class="cube" data-index="2"><span>MERKABA</span></div>
				<div class="cube" data-index="3"><span>FIBONACCI</span></div>
				<div class="cube" data-index="4"><span>CHAKRA</span></div>
				<div class="cube" data-index="5"><span>GNOMON</span></div>
				<div class="cube" data-index="6"><span>TETRACTYS</span></div>
				<div class="cube" data-index="7"><span>MANDALAS</span></div>
			<!-- Add more cubes as needed -->
			</div>
		</main>
		<Footer />
		<script>
			function getRandomColor() {
				const r = Math.floor(Math.random() * 256);
				const g = Math.floor(Math.random() * 256);
				const b = Math.floor(Math.random() * 256);
				return `rgb(${r},${g},${b})`;
			}


		
			const words = ["METATRON", "MERKABA", "FIBONACCI", "CHAKRA", "TORUS", "PI", "PHI", "VORTEX", "GNOMON", "MANDALA", "AETHER", "HELIX", "TETRACTYS", "QUINCUNX"];
			let lastUsedWords: string[] = [];
		
			document.addEventListener('DOMContentLoaded', function() {
				const canvas = document.getElementById('trailCanvas') as HTMLCanvasElement | null;
				if (canvas) {
					canvas.width = window.innerWidth;
					canvas.height = window.innerHeight;
					const ctx = canvas.getContext('2d');
          const scale = window.devicePixelRatio; // Get the device's pixel ratio
          canvas.width = window.innerWidth * scale;
          canvas.height = window.innerHeight * scale;
          canvas.style.width = window.innerWidth + 'px';
          canvas.style.height = window.innerHeight + 'px';
          ctx.scale(scale, scale);
					if (ctx) {
						const cubes = document.querySelectorAll('.cube');
						const canvasRect = canvas.getBoundingClientRect();
						const scene = document.querySelector('.scene') as HTMLElement;
						const sceneRect = scene.getBoundingClientRect();

						// Scene center in canvas coordinate space
						const centerX = (sceneRect.left + sceneRect.width / 2) - canvasRect.left;
						const centerY = (sceneRect.top + sceneRect.height / 2) - canvasRect.top;
		
						// Initialize lastUsedWords with empty strings for each cube
						lastUsedWords = Array.from({length: cubes.length}, () => "");
						function drawLine(ctx: CanvasRenderingContext2D, startX: number, startY: number, endX: number, endY: number, duration: number) {
    const startTime = performance.now();
	ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';

    function animateLineDrawing(currentTime: number) {
        const elapsedTime = currentTime - startTime;
        const progress = Math.min(elapsedTime / duration, 1);

        const currentX = startX + (endX - startX) * progress;
        const currentY = startY + (endY - startY) * progress;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(currentX, currentY);
        ctx.strokeStyle = getRandomColor();
        ctx.lineWidth = 5;
        ctx.stroke();

        if (progress < 1) {
            requestAnimationFrame(animateLineDrawing);
        }
    }

    requestAnimationFrame(animateLineDrawing);
}				
						cubes.forEach((cubeElement, index) => {
							const cube = cubeElement as HTMLElement;
		
							// Initialize last position to scene center in canvas coords
							let lastX = centerX;
							let lastY = centerY;
								
							function updateCube() {
								const randomX = (Math.random() * (window.innerWidth * 0.8)) - (window.innerWidth * 0.4);
								const randomY = (Math.random() * (window.innerHeight * 0.65)) - (window.innerHeight * 0.25);
								const randomColor = getRandomColor();

								let randomWordIndex, randomWord;
								do {
									randomWordIndex = Math.floor(Math.random() * words.length);
									randomWord = words[randomWordIndex];
								} while (lastUsedWords.includes(randomWord));
		
								cube.style.transform = `translate(${randomX}px, ${randomY}px)`;
								cube.style.backgroundColor = randomColor;
								const span = cube.querySelector('span');
								if (span) {
									span.textContent = randomWord;
								}
								lastUsedWords[index] = randomWord;

								// Draw line to cube target position in canvas coords
								const targetX = centerX + randomX;
								const targetY = centerY + randomY;
								drawLine(ctx, lastX, lastY, targetX, targetY, 2000);
								
								lastX = targetX;
								lastY = targetY;
							}

							updateCube();  // Initial update
							setInterval(updateCube, 3140);
						});
					}
				}
			});
			document.getElementById('downloadCanvas').addEventListener('click', function() {
    const canvas = document.getElementById('trailCanvas') as HTMLCanvasElement | null;
    if (canvas) {
        // Instead of directly setting the href to the data URL, create a Blob and use URL.createObjectURL
        canvas.toBlob(function(blob) {
            if (blob) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = 'canvas-image.png';
                link.href = url;
                // This part is crucial for mobile browsers - simulate a click event
                document.body.appendChild(link); // Append the link to the document
                link.click(); // Simulate a click
                document.body.removeChild(link); // Remove the link after triggering the download
                URL.revokeObjectURL(url); // Clean up the URL object
            }
        }, 'image/png');
    }
});
		</script>
		
			
			
	</body>
</html>

